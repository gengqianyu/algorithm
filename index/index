
索引的到底是什么?
数据库索引，是数据库管理系统(DBMS)中一个排序的数据结构。以协助快速查询，更新数据库表中的数据。
索引的本质就是一个索引列和磁盘数据地址，关联性数据结构

mysql索引类型
index 普通索引 没有任何限制的索引
unique 唯一索引 字段值不能有重复
primary key 主键索引 字段不能重复,not null 不允许有空值
fulltext key 全文索引 全文索引匹配语法 select * from fulltext_test where  match(content) against ("青山" IN NATURAL LANGUAGE MODE);

mysql索引方法
BTREE
HASH

索引的数据结构
有序数组:支持二分查找，修改困难，插入一个数据，后面的索引都得跟着走一遍。
单链表：修改容易，不支持二分查找
二叉查找树(Binary Search Tree BST): 左子树的节点<父节点，右子树的节点>父节点.天然有序的。
          13
       6      17
     2   11      22

     2 6 11 13 17 22
缺点：如果我们插入的数据天生有序，那么二叉树会退化成一个单向链表。只有右边的斜树，不够平衡。

平衡二叉树(AVL tree: Balanced Binary Search Trees ):左右子树深度差绝对值不能超过1
顺序插入1，2,3,4,5,6 ，一旦形成单链就通过左旋右旋形成下面这棵树。
         4(一个节点包含，1个索引字段，1个数据地址，各1个左右子节点地址指针)
    2        5
1      3         6

优点：左右平衡，方便查找
缺点：每次节点查找都要进行I/O操作，mysql InnoDB引擎一次I/O需要从磁盘拿到16k=16384bytes也就是一个内存页面大小的数据到内存。
      而AVL树的一个节点，最多也就几十个byte足够，如果利用AVL树话，本来一次I/O可以处理16k的数据，现在只能处理几十个bytes，会造成了I/O效率极低。
      AVL数的深度也太深，会大量增加I/O开销。

多路平衡查找树(Balanced Tree:B Tree)：节点拥有的子树数量称为度；关键字(索引字段)数：N，度(degree):N+1
为了解决AVL带来的磁盘和I/O的浪费，我们要在一个树节点上，放多个索引字段以及地址指针，再放多个指向下一个节点的地址指针。
B-Tree特点：每个节点指向子树的分叉指针个数：度，都比本个节点上的索引字段数N，大1。也就是度=N+1
B-Tree保持平衡：分裂和合并，如果定义的Max Degree=3 子节点数即将超过定义最大度3的时候就分裂。
1   2   3   分裂
    2
1       3

加强版的多路平衡查找树B+Tree：节点拥有的子树数量称为度；关键字(索引字段)数：N，度(degree 分叉数):N
B+Tree特点：
1 节点分为内节点(根节点和枝节点)和外节点(叶子节点)，内节点上只有N个关键字(索引字段)，N个指向子节点的地址指针。
2 外节点，除了N个关键字和N个指向子节点的指针外，还有指向关键字(索引字段)与之对应的表记录的物理地址指针(MyiSam)/行记录(InnoDB)。
3 正是由于以上特点，无论你查找那个字段，都要经过相同的I/O次数到达叶子节点，拿到记录的物理地址指针/记录。
4 所有相邻的叶子节点，还会形成一个双向的有序链表。如果需要进行全表扫描，不用去遍历树，从根节点依次查找，只需要从第1个叶子节点的开始依次遍历查找就可以。
5 因为有叶子节点的双向链表，所以B+Tree扫表能力更强，而且排序(因为是有序列表如果倒序直接反向遍历就可以)和范围查找能力也更强，不用去遍历树，直接操作链表。例如查找20到60，找到20然后依次遍历就可以了。
6 因为内节点中只存放关键字和节点指针，所以一个磁盘块16k(一般一个磁盘块和一个内存页大小相等)，所放的索引关键字会更多。I/O的效率也就更好，更稳定。

假设1条记录1KB的大小
一个磁盘块16kB
一个索引关键字+节点指针=14bytes
那么根节点可以放16384/14=1170(Degree 度)个单元
1170个枝节点可以有1170*1170=1368900(Degree 度)
一个叶子节点16k可以放16条记录
所有叶子节点有1368900*16=21902400条记录，千万级别。

HASH表不支持显示定义，在内存中使用
通过HASH码和索引列的映射，查找会很快，
缺点：存储是无序的，不能支持范围查找。排序查找。

数据库存储引擎？
存储引擎就是表类型。有MyiSAM Memory Innodb等
MyiSAM：每张表，由.frm文件(表结构定义文件)，.MYD(表数据文件),.MYI(表索引文件)
        查找一条行记录，每次先去.MYI索引文件遍历B+Tree，找到索引对应的行记录地址指针,再通过指针去.MYD去拿到对应行记录。
        其他索引数一样。
Innodb：每张表，由.frm文件(表结构定义文件),.ibd(索引即数据，数据即索引)
        查找一条行记录，直接去.ibd 文件，通过遍历B+Tree，找到叶子节点，既存储了主键索引，又存储了主键对应的行记录。直接拿出来就行。

正式因为MyiSam引擎索引和数据分离的原因，需要再去.MYD中操作行记录，得先锁整个表，不让别的修改请求进来修改了这条行记录。属于表锁。
而Innodb拿到索引就拿到行记录了，修改数据只需要锁住索引项对应的行记录就可以，也就是行级锁。

聚集(簇)索引？索引键值的逻辑顺序和行记录的物理存放顺序一致，就叫做聚集索引。比如主键索引。
如果一张table没有primary key 那么就找不包含空值的唯一索引作为聚集索引，如果唯一索引也没有，mysql会把隐藏的row_id作为聚集索引。
其他非聚集索引被称为二级(辅助)索引树，叶子节点存储(关键字)索引字段和行记录主键值。
通过辅助索引树检索行记录步骤：
1 通过辅助索引拿到主键；
2 再去主键索引树中拿到行记录。
所以辅助索引查询行记录会比主键索引慢。

为什么我创建了索引但是用不到呢？
联合索引
添加一个联合索引，ALTER TABLE user_innodb add INDEX `comidx_name_phone` (`name`,`phone`)
联合索引的最左匹配原则。
联合索引的字段是有顺序的。
                            (jack,181xx)(jason,185xxx)
(bob,189xx)(david,151xxx)                              (mic,179xx)(mic,180xxx)
                            多个键值的B+Tree

联合索引B+tree，节点中的索引是一个复合结构。前面是name后面是phone。也就说左边的name是有序的，如果name一样，那么它后面的phone才进行排序存放(例如mic)。
select的时候，想要用到索引，必须从最左边的字段开始匹配，不能中断；
用name去查询，name对于索引namePhone是有序的，当然能用到索引。
用phone去查询，phone对于索引namePhone是无序的，当然也就用不到索引。
select * from user_innodb where phone=`13xxx` and name=`mac` 能用到索引吗。
按照上面的规则，是不能用到索引的。
explain select * from user_innodb where phone=`13xxx` and name=`mac`分析一下结果发现是可以用到索引的。why？
是因为mysql优化器，自动调整了条件顺序，把name放在前面了，所以可以用到复合索引。

什么叫做回表？通过检索辅助索引，拿到叶子节点存储的行记录主键值，再去主键索引树检索行记录，这个多查一个B+tree的过程就叫做回表。
什么是覆盖索引？select的字段，已经包含在了使用的索引中的时候。也就是说你select的字段，刚好是你的索引字段。
例如，select name from user_innodb where name=`jack` 到name辅助索引树中查找记录，刚好我要的记录字段就是索引name。
没有要再通过主键去主键索引树中查到行记录了。name辅助索引中就有name的值。效率大大提高。
select phone from user_innodb where name="mac" 能用到覆盖索引吗？
条件name是可以用到联合索引的，phone又是联合索引中的字段，复合覆盖索引的定义，所以以上语句可以用到覆盖索引。
explain 结果中Extra 出现了using index的时候就表示用到了覆盖索引。
select phone from user_innodb where phone="131xx" 按照定义它用不到索引，
可是explain的结果依然可以用到覆盖索引，这都是优化器搞的鬼。

不要在索引列上使用计算，函数或者表达式，因为经过计算的结果往往是不确定的。
例如explain select * from `t2` where id+1=4 就不会用到索引。
字符串不加引号，出现隐式转换。
例如explain select * from `user` where phone=132 就不会使用到索引,132如果不加引号，就会当成整数处理
like条件前面带%(最左前缀)
例如explain select * from user_innodb where name like "wang%" 是可以用到索引的 匹配以wang开始name字段值可以用索引
例如explain select * from user_innodb where name like "%wang" 是不可以用到索引的 匹配以wang结束name字段值，不可能一个一个字符往后匹配找，这样就没有索引的意义了
负向查询 NOT LIKE 是不能用到索引的，<>不等于，和NOT IN是可以用到索引的。

索引能不能用到到底是谁决定的呢？优化器。基于成本的优化器，I/O的成本，CPU成本。数据量会影响成本。字段选择度。