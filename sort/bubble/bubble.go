//总结：
// 基本思想，通过对排序队列，从前向后，相邻的元素依次两两比较，如果发现两个数逆序就互换位置，这样一轮比较下来都有一个最大大的数被排在最后。
//			再进行下一轮找次大的方到后面。
//1 一共进行总数减1轮比较
//2 每轮需要两两比较的次数，是总数减1,再去轮数(每轮都把最大的一个数方到后面，下一轮就不用比较后面的大数了)。
package bubble

//冒泡排序 时间复杂度是O(n²)
func Sort(s []int) []int {
	//比较轮数 9个数比较到第8轮就剩一个数了，这个数就不用比较了，所以比较轮数也是要比较数减1
	for i := 0; i < len(s)-1; i++ {
		f := false
		//每轮两两比较次数 第一轮比完以后最大值就排在最后了，所以下一轮比较次数就减少一个，以此类推
		//9个数两两比较8次，不是9次。所以除了每轮排到最后的最大数，不用比较，比较次数还要比，要进行比较的数减1
		for j := 0; j < len(s)-i-1; j++ {
			if s[j] > s[j+1] {
				s[j], s[j+1] = s[j+1], s[j]

				f = true
			}
		}
		//如果发现有一轮比较没有发生位置变化，说明顺序已经是最总顺序了，无需进行下轮比较
		if f == false {
			break
		}
	}
	return s
}
