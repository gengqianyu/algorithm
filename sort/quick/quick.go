//快速排序
//快速排序是对冒泡排序的一种改进。
//基本思想：通过一轮排序，将要排序的数据分割成独立的两组数据，
//前一组的数据要比后一组的数据都要小，
//然后再按此方法，分别对这两组数据进行快速排序，
//整个过程只需要实现一次，其他都通过递归调用实现。
//以此达到整个数据变成有序序列

//设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用第一个数据）作为关键数据，
//然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。
//值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。

//一趟快速排序的算法是：
//1）设置前后两个开始位置i、j，排序开始的时候：i=0，j=N-1；
//2）以第一个数组元素作为中轴，赋值给p，即 p=i；
//3）从j开始向前搜索，即由后开始向前搜索（j -- ），找到第一个小于key的值A[j]，A[i]与A[j]交换；
//4）从i开始向后搜索，即由前开始向后搜索（i ++ ），找到第一个大于key的A[i]，A[i]与A[j]交换；
//5）重复第3、4、5步，直到 I=J；
//(3,4步是在程序中没找到时候j=j-1，i=i+1，直至找到为止。找到并交换的时候i， j指针位置不变。另外当i=j这过程一定正好是i+或j-完成的最后令循环结束。）
package quick

func Sort(s []int, l, r int) []int {
	//log.Println(s)
	//中轴值
	m := s[l]
	//pivot 选轴 这个中轴可以是任意一个数据，一般用第1个，最后1个，中间一个。
	p := l
	//定义before 和after 前后两个起始位置
	b, a := l, r

	//开始从左右两边向中间，以轴为准找复合条件的数
	for b <= a {
		//从右边这组数中找到一个比中轴小的数，找到比m小的值才退出, 不然一直往前找
		for a >= p && s[a] >= m {
			a--
		}
		//调整 把小数放前面
		if a >= p {
			s[p] = s[a]
			p = a
		}
		//log.Println(s)
		//从左边这组数据中找到一个比中轴大的数,找到比a[p]大的值才退出, 不然一直找
		for b <= p && s[b] <= m {
			b++
		}
		//调整 把大数放后面
		if b <= p {
			s[p] = s[b]
			p = b
		}

	}
	//一轮以后 p的位置移动到哪就赋值，完成一轮 以p为中轴，分为了两组，再非别递归
	s[p] = m
	//log.Println()
	//log.Println(s)
	if p-l > 1 {
		Sort(s, l, p-1)
	}

	if r-p > 1 {
		Sort(s, p+1, r)
	}
	return s
}
