//快速排序
//快速排序是对冒泡排序的一种改进。
//基本思想：通过一轮排序，将要排序的数据分割成独立的两组数据，
//前一组的数据要比后一组的数据都要小，
//然后再按此方法，分别对这两组数据进行快速排序，
//整个过程只需要实现一次，其他都通过递归调用实现。
//以此达到整个数据变成有序序列

//设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用第一个数据）作为关键数据，
//然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。
//值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。

package quick

func Sort(s []int, l, r int) []int {
	//1,让a,b两个索引位置，开始从左右两边向中间移动
	//2,a负责找到一个比中轴值m小的值，将这a位置上的值放到中轴索引p的位置，把中轴索引p置为a位置
	//3,b负责找到一个比中轴值m大的值，将这b位置上的值放到中轴索引p的位置(原来a的位置) ，把中轴索引p置为b位置
	//4,进入下一轮重复2,3步骤，找到一个比m小，比m大的值，通过p->a->b 中轴索引位置移动赋值操作，实现小数放左边，大数放右边，p位置变一直在变。
	//5,直到最后一轮，当左边没有比中轴值m大的值，右边没有比中轴m小的值。
	//6,把中轴值m重新放到中轴索引p的位置上(也就是最后一个a或b的位置)，m值并未发生变化。
	//7,经过了这样一整轮后，将数据以m为轴分成了两组，满足了左边所有值都比m小，右边都比m大。但不能保证两组数据就是有序的。
	//8,将两组数据，分别递归再次排序，直到两组数据成为有序序列
	//流程图
	//第一轮 m=s[0]=3
	//	 	b			   a
	//   3, 5, 7, 1, 2, 6, 0
	//	 p

	//	 	b			   a
	//   0, 5, 7, 1, 2, 6, 0
	//	 3->0			   p

	//	 	b			   a
	//   0, 5, 7, 1, 2, 6, 5
	//	 	p			   0->5
	//第2轮
	//	 	   b	  a
	//   0, 5, 7,  1, 2, 6, 5
	//	 	p

	//	 	   b	 a
	//   0, 2, 7, 1, 2, 6, 5
	//	   5->2 	 p

	//	 	   b	 a
	//   0, 2, 7, 1, 7, 6, 5
	//	       p	 2->7
	//第三轮
	//	 	      ba
	//   0, 2, 7, 1, 7, 6, 5
	//	       p

	//	 	       a
	//   0, 2, 1,  1, 7, 6, 5
	//	      7->1 p

	//	 	   	  b(s[b]不满足>m条件所以不做任何操作)
	//   0, 2, 1, 1, 7, 6, 5
	//	       	  p
	//所有轮数完成 中轴值m赋值到中轴索引p的位置，完成以3为轴前后分组
	//	 	   	  1->3(s[p]=m)
	//   0, 2, 1, 3, 7, 6, 5
	//	       	  p

	//中轴值
	m := s[l]
	//pivot 选轴 中轴索引可以是任意一个数据，一般用第1个，最后1个，中间一个。
	p := l
	//定义before 和after 前后两个起始位置
	b, a := l, r
	for b <= a {
		//从右边这组数中找到一个比中轴小的数，找到比m小的值才退出, 不然一直往前找
		for a >= p && s[a] >= m {
			a--
		}
		//调整把小数放前面
		if a >= p {
			s[p] = s[a]
			p = a
		}
		//log.Println(s)
		//从左边这组数据中找到一个比中轴大的数,找到比a[p]大的值才退出, 不然一直找
		for b <= p && s[b] <= m {
			b++
		}
		//调整 把大数放后面
		if b <= p {
			s[p] = s[b]
			p = b
		}

	}
	//把中轴值m重新放到，中轴索引p的位置上。中轴的值还是初始值m,
	//
	//一轮以后 p的位置就是m中轴的值，也就是把m经过比较调到到中间，把数据分为两组。
	s[p] = m
	//log.Println()
	//log.Println(s)
	if p-l > 1 {
		Sort(s, l, p-1)
	}

	if r-p > 1 {
		Sort(s, p+1, r)
	}
	return s
}
