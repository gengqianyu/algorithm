//希尔排序
//希尔排序是简单插入排序经过改进之后的一个更高效版本，也称之为缩小增量排序。
//基本思想
//希尔排序是把记录按索引的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法终止
//例如
//1对原始数据(8,9,1,7,2,3,5,4,6,0)进行排序
//2以索引增量(步长) 10=len/2进行数据分组。整个数据被分为了5组，(8,3),(9,5),(1,4),(7,6),(2,0)
//3对这5组数据分别进行直接插入排序得到，(3,5,1,6,0,8,9,4,7,2),8和3的位置发生变化，9和5的位置发生变化依次类推
//4以索引增量 2=5/2 把数据分为了两组(3,1,0,9,7) (5,6,8,4,2)
//5对这两组数据分别进行直接插入排序得到，(0,2,1,4,3,5,7,6,9,8),(3,1,0,9,7)排序得到(0,1,3,7,9)0和3的位置发生了交换，9和7发生了位置交换，
//6再次缩小增量 1=2/2 步长为1，共一组，因此是(0,2,1,4,3,5,7,6,9,8)
//7对步骤6的数据进行直接插入排序，得到(0,1,2,3,4,5,6,7,8,9)
package shell

func Sort(s []int) []int {
	//对要进行排序的数进行分组,每一次分组元素数量都是上一次分组的一半
	//10个数第1次分为5组，每组2个数进行比较排序，
	//第2次分为两组，每组5个元素比较排序，
	//第3次分为1个组，组中10个元素比较排序。
	for g := len(s) / 2; g > 0; g /= 2 {
		//每组进行插入排序
		for i := g; i < len(s); i++ {
			//遍历各组中所有的元素(共g组)，步长是g
			for j := i - g; j >= 0; j -= g {
				//每组中元素两两比较，复合条件交换位置
				if s[j] > s[j+g] {
					s[j], s[j+g] = s[j+g], s[j]
				}
			}
		}

	}
	return s
}

func Sort2(s []int) []int {
	//数据分组
	for g := len(s) / 2; g > 0; g /= 2 {
		//每组进行直接插入排序 开始位置是
		for i := g; i < len(s); i++ {
			// 将交换改成移动
			//定义要进行插入位置的索引
			j := i
			//保存移动位的值
			t := s[j]
			//if s[j] < s[j-g] {
			//分组元素不越界，s[j]与它一个组的前一个元素s[j-g]比较，如果比它大就移动
			for j-g >= 0 && t < s[j-g] {
				//s[j] 就是后面那个数
				s[j] = s[j-g]
				j -= g
			}
			//循环退出，就是插入位置
			s[j] = t
			//}
		}

	}
	return s
}
