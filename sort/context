排序算法

    排序算法的介绍
        排序也称排序算法（sort algorithm）排序是将一组数据，依指定的顺序进行排序的过程
    排序算法的分类
        内部排序：将需要处理的所有数据都加载到内存中进行排序
                插入排序:直接插入排序，希尔排序
                选择排序：简单选择排序，堆排序
                交换排序：冒泡排序，快速排序
                归并排序
                基数排序

        外部排序：由于数据量过大，无法加载全部数据到内存，需要借助外存进行排序。（并行计算，云计算）

算法的时间复杂度 按照顺序发杂度依次增加

1 常数阶O(1)
无论执行代码多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度都是O(1)
例如：
i:=1
j:=2
i++
j++
m:=i+j
上述代码执行，消耗的时间并不随某个变量的增长而增长，无论代码有多长，都可以用O(1)来表示它的时间复杂度。

2 对数阶O(log2n)
log以2为底，n的对数。(log以2为底，1024的对数是10)
例如
i:=1
for i<n {
i=i*2
}
在for循环中，每次都将i乘以2,结果i距离n就越来越近了，假设循环x次后，i就大于n了，循环退出，也就是说无线接近 2的n次方等于n，那么x=log2n，
也就说循环log2n次以后代码结束了。那么这个时间复杂度就是O(log2n),O(log2n)这个2是根据代码变化的，i=i*3，则是O(log3n)

3线性阶O(n)
例如
for i:=1;i<=n;i++ {
    j:=i
    j++
}
这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码可用O(n)来表示它的时间复杂度。

4 线性对数阶O(nlogN)
例如
for j:=1;j<n;j++ {
    for i<n {
        i:=i*2
    }

}
线性对数阶O(nlogN)其实非常容易理解，将时间复杂度O(logn)的代码循环N遍，那么它的时间复杂度就是n*O(nlogN),也就是O(nlogN)

5 平方阶O(n²)
例如
for j:=1;i<=n;j++{
    for i:=1;i<=n;i++{
        j=i
        j++
    }
}
平方阶O(n²)就更容易理解了，如果把O(n)的代码再循环嵌套一遍，它的时间复杂度就是O(n²)，这段代码嵌套了2层n次循环，它是时间复杂度就是O(n*n)，
即O(n²)，如果一层循环改成m那么它的时间复杂度就是O(n*m)

6 立方阶O(n³) k次方阶
参考上面的平阶理解就好，O(n³)相当于三次循环。其他类似

7 指数阶O(2^n)

八大平均时间复杂度和最坏时间复杂度：
排序法 平均时间复杂度 最差时间复杂度 稳定度 额外空间   备注

冒泡      O(n²)       O(n²)        稳定      O(1)   n小时较好

交换      O(n²)       O(n²)        不稳定    O(1)    n小时较好

选择      O(n²)       O(n²)        不稳定    O(1)    n小时较好

插入      O(n²)       O(n²)        稳定      O(1)    大部分已排序时较好

基数      O(logRB)    O(logRB)     稳定      O(n)     B是真数0-9，R是基数(个十百)

希尔      O(nlogn)    O(n^s)1<s<2  不稳定    O(1)     s是所选分组

快速      O(nlogn)    O(n²)        不稳定    O(nlogn)  n大时较好

归并      O(nlogn)    O(nlogn)     稳定      O(1)       n大时较好

堆排      O(nlogn)    O(nlogn)     不稳定    O(1)        n大时较好


算法的空间复杂度
1 类似的时间复杂度讨论，一个算法的空间复杂度定义为该算法所消耗的内存空间，
2 空间复杂度是对一个算法在运行过程中临时占用内存空间大小的量度，有的算法需要占用临时工作单元数，与解决问题的规模n有关，n越大占用的存储空间也就越大。
  例如快速和归并。
3 在算法分析时，主要讨论的是时间复杂度，从用户的体验上看，更看重程序的执行速度，一些缓存产品memcache，redis和算法基数排序，本质就是空间换时间。