//插入排序的基本思想
//把n个待排序的元素看成为一个有序队列和一个无序队列，
//开始时有序队列里只包含一个元素，无序队列中包含有n-1个元素，
//排序过程中每次从无序队列中取出一个元素，和有序队列中元素进行比较，
//将它插入到有序表中的适当位置
package insert

//{3, 0, 7, 8, 9, 4, 1, 2, 6, 5},
//效率不如下面的优化版本，而且还占内存
func Sort(s []int) []int {
	//初始化有序列表
	var p []int

	for _, e := range s {
		//第一次循环直接在有序队列中插入第一个值
		if len(p) == 0 {
			p = append(p, e)
			continue
		}
		//默认插入位置是1
		t := 1
		//找插入位置
		for i := 0; i < len(p); i++ {
			//找到插入位置就跳出去插入,因为t是插入位置所以是索引+1
			if e <= p[i] {
				t = i + 1
				break
			}
			t++
		}
		//log.Fatal(t)

		// p[b:] 拿到slice中从b位置以后的element，不包含b。p[:b] 拿到b位置以前的element，包含b ，
		// p[a:b] a到b所有element ，同理不包含a，包含b 也就是"后包前不包"
		//注意：保存后部剩余元素，必须新建一个临时切片, b=p[t-1:]不行，因为b和p公用底层数组会发生错误
		b := append([]int{}, p[t-1:]...)
		p = append(append(p[:t-1], e), b...)
		//log.Println(p)
	}

	return p
}

//插入排序简化版本
//时间复杂度O(n²)
//D:\go\algorithm\sort\insert>go test --bench=".*" --benchmem -v
//goos: windows
//goarch: amd64
//pkg: algorithm/sort/insert
//BenchmarkSort-8           149996              7228 ns/op               0 B/op          0 al
//locs/op
//PASS
//ok      algorithm/sort/insert   1.679s

//{3, 0, 7, 8, 9, 4, 1, 2, 6, 5},原始
//{0, 3, 7, 8, 9, 4, 1, 2, 6, 5},第1轮 0与3比较，0小 ，0动
//{0, 3, 7, 8, 9, 4, 1, 2, 6, 5},第2轮 7与3,0比较，7大，7不动
//{0, 3, 7, 8, 9, 4, 1, 2, 6, 5},第3轮 8与7，3,0比较，,8大，8不动
//{0, 3, 7, 8, 9, 4, 1, 2, 6, 5},第2轮 9与8，7，3,0比较，,,9大，9不动
//{0, 3, 4, 7, 8, 9, 1, 2, 6, 5},第2轮 4与9，8，7，3,0比较,4小，4动(每次比较前面的数往后移动一个，直到3条件不成立，插入的位置是原先是7的初始位)
//依次类推

func Sort2(s []int) []int {
	//一共需要比较len(s)-1次
	for i := 1; i < len(s); i++ {

		t := s[i]  //定义待插入的数 从索引为1的第2个数开始
		o := i - 1 //定义要插入的位置  无条件默认插入位置为索引为0的第1个数的位置

		//给t找到一个要插入的位置
		//1 >=0保证向前不越界
		//2 t < s[o] 4每次和t的前一个元素对比，如果比前一个元素小，前一个元素后移1位。产生两个一样的位s[0]和s[1] 类似{0, 3,7, 8, 9，9(原先4的位置)}
		//3 o-- 接着对比，前一个元素的前一个元素，如果满足条件，前前个元素接着后移 类似{0, 3,7, 8, 8(9)，9(4)} 依次类推
		//4 s[o+1] = t 直到3的位置不满足条件，跳出循环在3的后面，也就是7的位置插入4。类似类似{0, 3,4(7), 7(8), 8(9)，9(4)} 完成插入4的操作
		for o >= 0 && t < s[o] {
			s[o+1] = s[o]
			o--
		}
		//因为for循环中最后o--是希望在o的前一个位置插入，如果条件不成立，是要插在o这个位置的,所以+1，从o--变回o的位置
		//插入位置如果和i相等说明位置不用变，加上以后每次多一次判断，并不能增加效率
		//if o+1 != i {
		s[o+1] = t
		//}

	}
	return s
}
